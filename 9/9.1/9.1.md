# 9.1. Índices

## Módulos

### 1. Planificación del mantenimiento:
   
1) Índice para la búsqueda de planes de mantenimiento según la máquina a reparar:
    
* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.id_maquina = 8
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=62.13..62.14 rows=3 width=268) (actual time=0.173..0.174 rows=3 loops=1)"
    "  ->  Sort  (cost=62.13..62.14 rows=3 width=268) (actual time=0.171..0.172 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.59..62.11 rows=3 width=268) (actual time=0.056..0.164 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=0.44..61.41 rows=3 width=94) (actual time=0.043..0.147 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..45.39 rows=3 width=20) (actual time=0.033..0.133 rows=3 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=3 width=16) (actual time=0.022..0.117 rows=3 loops=1)"
    "                                Filter: (id_maquina = 8)"
    "                                Rows Removed by Filter: 997"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.003..0.003 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.674 ms"
    "Execution Time: 0.659 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Maquina_mantto
    ON Mantenimiento(id_maquina);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=52.46..52.46 rows=3 width=268) (actual time=0.129..0.131 rows=3 loops=1)"
    "  ->  Sort  (cost=52.46..52.46 rows=3 width=268) (actual time=0.127..0.129 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=4.88..52.43 rows=3 width=268) (actual time=0.097..0.119 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=4.73..51.73 rows=3 width=94) (actual time=0.082..0.098 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=4.57..35.72 rows=3 width=20) (actual time=0.070..0.080 rows=3 loops=1)"
    "                          ->  Bitmap Heap Scan on mantenimiento m  (cost=4.30..10.82 rows=3 width=16) (actual time=0.058..0.061 rows=3 loops=1)"
    "                                Recheck Cond: (id_maquina = 8)"
    "                                Heap Blocks: exact=2"
    "                                ->  Bitmap Index Scan on idx_maquina_mantto  (cost=0.00..4.30 rows=3 width=0) (actual time=0.052..0.052 rows=3 loops=1)"
    "                                      Index Cond: (id_maquina = 8)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.005..0.005 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 2.329 ms"
    "Execution Time: 0.232 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 62.14.
  - Luego de implementar, el costo nuevo es 52.46.
  - Esto muestra una reducción del 15.58% en costo.

1) Índice para la búsqueda de planes de mantenimiento según la fecha de inicio programada:

* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.fecha_inicio_programado = DATE('2023-07-17')
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=37.24..37.25 rows=1 width=268) (actual time=0.293..0.294 rows=2 loops=1)"
    "  ->  Sort  (cost=37.24..37.25 rows=1 width=268) (actual time=0.273..0.274 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.58..37.23 rows=1 width=268) (actual time=0.181..0.250 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.43..37.00 rows=1 width=94) (actual time=0.154..0.219 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..28.81 rows=1 width=20) (actual time=0.136..0.198 rows=2 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=1 width=16) (actual time=0.110..0.166 rows=2 loops=1)"
    "                                Filter: (fecha_inicio_programado = '2023-07-17'::date)"
    "                                Rows Removed by Filter: 998"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.012..0.012 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.008..0.008 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.441 ms"
    "Execution Time: 0.367 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Fecha_mantto
    ON Mantenimiento(fecha_inicio_programado)
    ```

    * Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=25.03..25.04 rows=1 width=268) (actual time=0.112..0.113 rows=2 loops=1)"
    "  ->  Sort  (cost=25.03..25.04 rows=1 width=268) (actual time=0.111..0.112 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.85..25.02 rows=1 width=268) (actual time=0.085..0.094 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.70..24.79 rows=1 width=94) (actual time=0.069..0.075 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.55..16.60 rows=1 width=20) (actual time=0.060..0.065 rows=2 loops=1)"
    "                          ->  Index Scan using idx_fecha_mantto on mantenimiento m  (cost=0.28..8.29 rows=1 width=16) (actual time=0.048..0.049 rows=2 loops=1)"
    "                                Index Cond: (fecha_inicio_programado = '2023-07-17'::date)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.006..0.006 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 1.762 ms"
    "Execution Time: 0.155 ms"
    ```

* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 37.25.
  - Luego de implementar el índice, el costo nuevo es 25.04.
  - Esto muestra una reducción del 32.78% en costo.

---

### 2. Control del mantenimiento

### 3. Gestión de equipos de soporte

### 4. Gestión del IPERC

### 5. Gestión de insumos
---
1) Índice para la búsqueda de registros para la creacion de reportes.
    
* Query utilizado:
    
    ```sql
    EXPLAIN ANALYSE
    SELECT 
    'R' || TO_CHAR(rep.Fecha_reporte, 'YYYYMMDD') AS Codigo_Registro,
    rep.Fecha_reporte::date AS Fecha_del_Dia,
    registros_por_dia.total,
    rep.Fecha_reporte,
    est.nombre_estado AS "Estado_Reporte",
    rep.id_jefe
    FROM  
        reportes rep
    INNER JOIN 
        (SELECT 
            fecha_registro::date AS fecha_del_dia, 
            COUNT(*) AS total 
        FROM registro
        WHERE fecha_inicial BETWEEN '2024-05-12' AND '2024-12-10'
        GROUP BY fecha_registro::date) AS registros_por_dia
    ON rep.fecha_reporte::date = registros_por_dia.fecha_del_dia

    JOIN 
    Estado_Reporte AS est ON rep.id_estado_reporte = est.id_estado_reporte
    ORDER BY rep.fecha_reporte::date
    LIMIT 10 OFFSET 0;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=72.23..73.08 rows=10 width=568) (actual time=1.876..1.895 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=72.23..93.73 rows=253 width=568) (actual time=1.875..1.893 rows=10 loops=1)"
    "        ->  Merge Join  (cost=72.08..84.54 rows=253 width=20) (actual time=1.182..1.191 rows=10 loops=1)"
    "              Merge Cond: (((registro.fecha_registro)::date) = rep.fecha_reporte)"
    "              ->  GroupAggregate  (cost=52.01..57.39 rows=253 width=12) (actual time=0.278..0.310 rows=129 loops=1)"
    "                    Group Key: ((registro.fecha_registro)::date)"
    "                    ->  Sort  (cost=52.01..52.75 rows=296 width=4) (actual time=0.273..0.278 rows=161 loops=1)"
    "                          Sort Key: ((registro.fecha_registro)::date)"
    "                          Sort Method: quicksort  Memory: 25kB"
    "                          ->  Seq Scan on registro  (cost=0.00..39.86 rows=296 width=4) (actual time=0.114..0.210 rows=299 loops=1)"
    "                                Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                Rows Removed by Filter: 709"
    "              ->  Sort  (cost=20.07..20.76 rows=278 width=12) (actual time=0.869..0.871 rows=29 loops=1)"
    "                    Sort Key: rep.fecha_reporte"
    "                    Sort Method: quicksort  Memory: 35kB"
    "                    ->  Seq Scan on reportes rep  (cost=0.00..8.78 rows=278 width=12) (actual time=0.008..0.037 rows=278 loops=1)"
    "        ->  Memoize  (cost=0.15..0.35 rows=1 width=520) (actual time=0.003..0.003 rows=1 loops=10)"
    "              Cache Key: rep.id_estado_reporte"
    "              Cache Mode: logical"
    "              Hits: 9  Misses: 1  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reporte_pkey on estado_reporte est  (cost=0.14..0.34 rows=1 width=520) (actual time=0.026..0.026 rows=1 loops=1)"
    "                    Index Cond: (id_estado_reporte = rep.id_estado_reporte)"
    "Planning Time: 2.393 ms"
    "Execution Time: 2.065 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_registros_fecha ON Registro(Fecha_inicial, fecha_registro);
    CREATE INDEX idx_reportes_fecha ON reportes (fecha_reporte);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=52.31..54.42 rows=10 width=568) (actual time=0.403..0.436 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=52.31..105.52 rows=253 width=568) (actual time=0.402..0.434 rows=10 loops=1)"
    "        ->  Merge Join  (cost=52.16..96.33 rows=253 width=20) (actual time=0.368..0.388 rows=10 loops=1)"
    "              Merge Cond: (rep.fecha_reporte = ((registro.fecha_registro)::date))"
    "              ->  Index Scan using idx_reportes_fecha_reporte on reportes rep  (cost=0.15..32.55 rows=278 width=12) (actual time=0.071..0.082 rows=29 loops=1)"
    "              ->  GroupAggregate  (cost=52.01..57.39 rows=253 width=12) (actual time=0.220..0.289 rows=129 loops=1)"
    "                    Group Key: ((registro.fecha_registro)::date)"
    "                    ->  Sort  (cost=52.01..52.75 rows=296 width=4) (actual time=0.214..0.223 rows=161 loops=1)"
    "                          Sort Key: ((registro.fecha_registro)::date)"
    "                          Sort Method: quicksort  Memory: 25kB"
    "                          ->  Seq Scan on registro  (cost=0.00..39.86 rows=296 width=4) (actual time=0.013..0.162 rows=299 loops=1)"
    "                                Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                Rows Removed by Filter: 709"
    "        ->  Memoize  (cost=0.15..0.35 rows=1 width=520) (actual time=0.003..0.003 rows=1 loops=10)"
    "              Cache Key: rep.id_estado_reporte"
    "              Cache Mode: logical"
    "              Hits: 9  Misses: 1  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reporte_pkey on estado_reporte est  (cost=0.14..0.34 rows=1 width=520) (actual time=0.021..0.022 rows=1 loops=1)"
    "                    Index Cond: (id_estado_reporte = rep.id_estado_reporte)"
    "Planning Time: 1.822 ms"
    "Execution Time: 0.544 ms"
    ```

* Implementación de segundo índice en la misma consulta:

    ```sql
    CREATE INDEX idx_estado_reserva ON Estado_reserva(Id_estado_reserva);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=0.28..2.99 rows=10 width=532) (actual time=0.102..0.124 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=0.28..17.10 rows=62 width=532) (actual time=0.100..0.120 rows=10 loops=1)"
    "        ->  Index Scan using idx_reserva_fecha_hora on reserva r  (cost=0.14..14.14 rows=62 width=20) (actual time=0.015..0.021 rows=10 loops=1)"
    "              Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "              Rows Removed by Filter: 3"
    "        ->  Memoize  (cost=0.14..0.35 rows=1 width=520) (actual time=0.009..0.009 rows=1 loops=10)"
    "              Cache Key: r.id_estado_reserva"
    "              Cache Mode: logical"
    "              Hits: 8  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using idx_estado_reserva on estado_reserva e  (cost=0.13..0.34 rows=1 width=520) (actual time=0.038..0.038 rows=1 loops=2)"
    "                    Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 2.962 ms"
    "Execution Time: 0.187 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 10.01.
  - Luego de implementar el primer índice, el costo fue de 0.30.
  - Luego de implementar el segundo índice, el costo fue de 0.28.
  - Esto muestra una reducción del 97.2% en costo.

---
### 6. Seguridad

### 7. Gestión de reportes e historial de mantenimiento
---
1) Indice para la busqueda de Registros mediante la fecha del registro

* Query Utilizado:

    ```sql
    EXPLAIN ANALYSE
    SELECT  
    nombre_tipo AS "Nombre deMáquina", 
    e.Nombre AS "Técnico Responsable",
    tm.nombre_tipo_mant AS "TipoMantenimiento",
    r.Fecha_inicial AS "Fecha Inicio",
    r.Fecha_registro AS "Fecha Final",
    r.Calificacion  ,
    r.Observaciones  
    FROM  
    Registro r  
    INNER JOIN  
    Mantenimiento m ON r.Id_Act_manttm.Id_Act_mantto  
    INNER JOIN 
    Empleado e ON r.Id_empleado Id_empleado  
    INNER JOIN  
    Tipo_mantenimiento tm Oid_tipo_mant = tm.id_tipo_mant  
    INNER JOIN  
    Maquina m2 ON m.id_maquina =id_maquina  
    INNER JOIN 
    tipo_maquina ON tipo_maquid_tipo_maquina = m2.id_tipo_maquina 
    WHERE
    r.Fecha_inicial BETWEEN '2024-05-12' AND '2024-12-10'
    ORDER BY 
    r.Fecha_inicial
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Sort  (cost=169.90..170.64 rows=296 width=676) (actual time=2.402..2.419 rows=299 loops=1)"
    "  Sort Key: r.fecha_inicial"
    "  Sort Method: quicksort  Memory: 63kB"
    "  ->  Nested Loop  (cost=116.91..157.75 rows=296 width=676) (actual time=1.452..2.200 rows=299 loops=1)"
    "        ->  Nested Loop  (cost=116.76..149.12 rows=296 width=164) (actual time=1.440..2.015 rows=299 loops=1)"
    "              ->  Hash Join  (cost=116.60..141.08 rows=296 width=90) (actual time=1.420..1.841 rows=299 loops=1)"
    "                    Hash Cond: (r.id_empleado = e.id_empleado)"
    "                    ->  Hash Join  (cost=74.10..97.81 rows=296 width=79) (actual time=0.940..1.231 rows=299 loops=1)"
    "                          Hash Cond: (m2.id_maquina = m.id_maquina)"
    "                          ->  Seq Scan on maquina m2  (cost=0.00..17.00 rows=1000 width=8) (actual time=0.010..0.099 rows=1000 loops=1)"
    "                          ->  Hash  (cost=70.40..70.40 rows=296 width=79) (actual time=0.920..0.921 rows=299 loops=1)"
    "                                Buckets: 1024  Batches: 1  Memory Usage: 41kB"
    "                                ->  Hash Join  (cost=30.50..70.40 rows=296 width=79) (actual time=0.404..0.802 rows=299 loops=1)"
    "                                      Hash Cond: (r.id_act_mantto = m.id_act_mantto)"
    "                                      ->  Seq Scan on registro r  (cost=0.00..39.12 rows=296 width=75) (actual time=0.010..0.210 rows=299 loops=1)"
    "                                            Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                            Rows Removed by Filter: 709"
    "                                      ->  Hash  (cost=18.00..18.00 rows=1000 width=12) (actual time=0.374..0.374 rows=1022 loops=1)"
    "                                            Buckets: 1024  Batches: 1  Memory Usage: 52kB"
    "                                            ->  Seq Scan on mantenimiento m  (cost=0.00..18.00 rows=1000 width=12) (actual time=0.009..0.199 rows=1022 loops=1)"
    "                    ->  Hash  (cost=30.00..30.00 rows=1000 width=19) (actual time=0.468..0.469 rows=1000 loops=1)"
    "                          Buckets: 1024  Batches: 1  Memory Usage: 60kB"
    "                          ->  Seq Scan on empleado e  (cost=0.00..30.00 rows=1000 width=19) (actual time=0.018..0.190 rows=1000 loops=1)"
    "              ->  Memoize  (cost=0.16..0.23 rows=1 width=82) (actual time=0.000..0.000 rows=1 loops=299)"
    "                    Cache Key: m.id_tipo_mant"
    "                    Cache Mode: logical"
    "                    Hits: 297  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..0.22 rows=1 width=82) (actual time=0.007..0.007 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "        ->  Memoize  (cost=0.15..0.22 rows=1 width=520) (actual time=0.000..0.000 rows=1 loops=299)"
    "              Cache Key: m2.id_tipo_maquina"
    "              Cache Mode: logical"
    "              Hits: 294  Misses: 5  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using tipo_maquina_pkey on tipo_maquina  (cost=0.14..0.21 rows=1 width=520) (actual time=0.003..0.003 rows=1 loops=5)"
    "                    Index Cond: (id_tipo_maquina = m2.id_tipo_maquina)"
    "Planning Time: 1.278 ms"
    "Execution Time: 2.582 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_registros_dia on Registro(Fecha_inicial, fecha_registro);
    ```

* Plan de ejecución luego de ejecutar el indice:

    ```sql
    "Sort  (cost=169.90..170.64 rows=296 width=676) (actual time=1.591..1.613 rows=299 loops=1)"
    "  Sort Key: r.fecha_inicial"
    "  Sort Method: quicksort  Memory: 63kB"
    "  ->  Nested Loop  (cost=116.91..157.75 rows=296 width=676) (actual time=0.836..1.460 rows=299 loops=1)"
    "        ->  Nested Loop  (cost=116.76..149.12 rows=296 width=164) (actual time=0.819..1.317 rows=299 loops=1)"
    "              ->  Hash Join  (cost=116.60..141.08 rows=296 width=90) (actual time=0.807..1.164 rows=299 loops=1)"
    "                    Hash Cond: (r.id_empleado = e.id_empleado)"
    "                    ->  Hash Join  (cost=74.10..97.81 rows=296 width=79) (actual time=0.537..0.815 rows=299 loops=1)"
    "                          Hash Cond: (m2.id_maquina = m.id_maquina)"
    "                          ->  Seq Scan on maquina m2  (cost=0.00..17.00 rows=1000 width=8) (actual time=0.006..0.084 rows=1000 loops=1)"
    "                          ->  Hash  (cost=70.40..70.40 rows=296 width=79) (actual time=0.522..0.523 rows=299 loops=1)"
    "                                Buckets: 1024  Batches: 1  Memory Usage: 41kB"
    "                                ->  Hash Join  (cost=30.50..70.40 rows=296 width=79) (actual time=0.251..0.451 rows=299 loops=1)"
    "                                      Hash Cond: (r.id_act_mantto = m.id_act_mantto)"
    "                                      ->  Seq Scan on registro r  (cost=0.00..39.12 rows=296 width=75) (actual time=0.006..0.133 rows=299 loops=1)"
    "                                            Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                            Rows Removed by Filter: 709"
    "                                      ->  Hash  (cost=18.00..18.00 rows=1000 width=12) (actual time=0.237..0.237 rows=1022 loops=1)"
    "                                            Buckets: 1024  Batches: 1  Memory Usage: 52kB"
    "                                            ->  Seq Scan on mantenimiento m  (cost=0.00..18.00 rows=1000 width=12) (actual time=0.005..0.123 rows=1022 loops=1)"
    "                    ->  Hash  (cost=30.00..30.00 rows=1000 width=19) (actual time=0.263..0.263 rows=1000 loops=1)"
    "                          Buckets: 1024  Batches: 1  Memory Usage: 60kB"
    "                          ->  Seq Scan on empleado e  (cost=0.00..30.00 rows=1000 width=19) (actual time=0.012..0.120 rows=1000 loops=1)"
    "              ->  Memoize  (cost=0.16..0.23 rows=1 width=82) (actual time=0.000..0.000 rows=1 loops=299)"
    "                    Cache Key: m.id_tipo_mant"
    "                    Cache Mode: logical"
    "                    Hits: 297  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..0.22 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "        ->  Memoize  (cost=0.15..0.22 rows=1 width=520) (actual time=0.000..0.000 rows=1 loops=299)"
    "              Cache Key: m2.id_tipo_maquina"
    "              Cache Mode: logical"
    "              Hits: 294  Misses: 5  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using tipo_maquina_pkey on tipo_maquina  (cost=0.14..0.21 rows=1 width=520) (actual time=0.004..0.004 rows=1 loops=5)"
    "                    Index Cond: (id_tipo_maquina = m2.id_tipo_maquina)"
    "Planning Time: 0.684 ms"
    "Execution Time: 1.768 ms"
    ```