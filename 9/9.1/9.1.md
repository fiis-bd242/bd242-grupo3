# 9.1. Índices

## Módulos

### 1. Planificación del mantenimiento:
   
1) Índice para la búsqueda de planes de mantenimiento según la máquina a reparar:
    
* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.id_maquina = 8
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=62.13..62.14 rows=3 width=268) (actual time=0.173..0.174 rows=3 loops=1)"
    "  ->  Sort  (cost=62.13..62.14 rows=3 width=268) (actual time=0.171..0.172 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.59..62.11 rows=3 width=268) (actual time=0.056..0.164 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=0.44..61.41 rows=3 width=94) (actual time=0.043..0.147 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..45.39 rows=3 width=20) (actual time=0.033..0.133 rows=3 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=3 width=16) (actual time=0.022..0.117 rows=3 loops=1)"
    "                                Filter: (id_maquina = 8)"
    "                                Rows Removed by Filter: 997"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.003..0.003 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.674 ms"
    "Execution Time: 0.659 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Maquina_mantto
    ON Mantenimiento(id_maquina);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=52.46..52.46 rows=3 width=268) (actual time=0.129..0.131 rows=3 loops=1)"
    "  ->  Sort  (cost=52.46..52.46 rows=3 width=268) (actual time=0.127..0.129 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=4.88..52.43 rows=3 width=268) (actual time=0.097..0.119 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=4.73..51.73 rows=3 width=94) (actual time=0.082..0.098 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=4.57..35.72 rows=3 width=20) (actual time=0.070..0.080 rows=3 loops=1)"
    "                          ->  Bitmap Heap Scan on mantenimiento m  (cost=4.30..10.82 rows=3 width=16) (actual time=0.058..0.061 rows=3 loops=1)"
    "                                Recheck Cond: (id_maquina = 8)"
    "                                Heap Blocks: exact=2"
    "                                ->  Bitmap Index Scan on idx_maquina_mantto  (cost=0.00..4.30 rows=3 width=0) (actual time=0.052..0.052 rows=3 loops=1)"
    "                                      Index Cond: (id_maquina = 8)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.005..0.005 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 2.329 ms"
    "Execution Time: 0.232 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 62.14.
  - Luego de implementar, el costo nuevo es 52.46.
  - Esto muestra una reducción del 15.58% en costo.

2) Índice para la búsqueda de planes de mantenimiento según la fecha de inicio programada:

* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.fecha_inicio_programado = DATE('2023-07-17')
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=37.24..37.25 rows=1 width=268) (actual time=0.293..0.294 rows=2 loops=1)"
    "  ->  Sort  (cost=37.24..37.25 rows=1 width=268) (actual time=0.273..0.274 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.58..37.23 rows=1 width=268) (actual time=0.181..0.250 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.43..37.00 rows=1 width=94) (actual time=0.154..0.219 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..28.81 rows=1 width=20) (actual time=0.136..0.198 rows=2 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=1 width=16) (actual time=0.110..0.166 rows=2 loops=1)"
    "                                Filter: (fecha_inicio_programado = '2023-07-17'::date)"
    "                                Rows Removed by Filter: 998"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.012..0.012 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.008..0.008 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.441 ms"
    "Execution Time: 0.367 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Fecha_mantto
    ON Mantenimiento(fecha_inicio_programado)
    ```

    * Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=25.03..25.04 rows=1 width=268) (actual time=0.112..0.113 rows=2 loops=1)"
    "  ->  Sort  (cost=25.03..25.04 rows=1 width=268) (actual time=0.111..0.112 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.85..25.02 rows=1 width=268) (actual time=0.085..0.094 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.70..24.79 rows=1 width=94) (actual time=0.069..0.075 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.55..16.60 rows=1 width=20) (actual time=0.060..0.065 rows=2 loops=1)"
    "                          ->  Index Scan using idx_fecha_mantto on mantenimiento m  (cost=0.28..8.29 rows=1 width=16) (actual time=0.048..0.049 rows=2 loops=1)"
    "                                Index Cond: (fecha_inicio_programado = '2023-07-17'::date)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.006..0.006 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 1.762 ms"
    "Execution Time: 0.155 ms"
    ```

* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 37.25.
  - Luego de implementar el índice, el costo nuevo es 25.04.
  - Esto muestra una reducción del 32.78% en costo.

---

### 2. Control del mantenimiento

Índice para la busqueda de la orden de trabajo segun la fecha en que fue programada

* Query utilizado:

```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
                CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
                tm.nombre_tipo_mant,
                c.nivel,
                m.fecha_inicio_programado,
                em.estado
                FROM Plan_de_Mantenimiento p
                INNER JOIN Mantenimiento m
                ON m.id_plan = p.id_plan
                INNER JOIN estado_mantto em
                ON em.id_estado = m.id_estado
                INNER JOIN Tipo_mantenimiento tm
                ON tm.id_tipo_mant = m.id_tipo_mant
                INNER JOIN Criticidad c
                ON c.id_criticidad = p.id_criticidad
		WHERE m.fecha_inicio_programado = DATE('2023-08-15')
                ORDER BY p.id_plan
                LIMIT 9
                OFFSET 1-1;
```

* Plan de ejecución antes de implementar el índice:

```sql
    "Limit  (cost=33.22..33.22 rows=1 width=326) (actual time=0.038..0.039 rows=1 loops=1)"
    "  ->  Sort  (cost=33.22..33.22 rows=1 width=326) (actual time=0.037..0.038 rows=1 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=1.00..33.21 rows=1 width=326) (actual time=0.032..0.033 rows=1 loops=1)"
    "              ->  Nested Loop  (cost=0.85..32.98 rows=1 width=152) (actual time=0.024..0.025 rows=1 loops=1)"
    "                    ->  Nested Loop  (cost=0.70..24.79 rows=1 width=78) (actual time=0.021..0.022 rows=1 loops=1)"
    "                          ->  Nested Loop  (cost=0.55..16.60 rows=1 width=24) (actual time=0.013..0.014 rows=1 loops=1)"
    "                                ->  Index Scan using idx_fecha_programada on mantenimiento m  (cost=0.28..8.29 rows=1 width=20) (actual time=0.005..0.005 rows=1 loops=1)"
    "                                      Index Cond: (fecha_inicio_programado = '2023-08-15'::date)"
    "                                ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.007..0.007 rows=1 loops=1)"
    "                                      Index Cond: (id_plan = m.id_plan)"
    "                          ->  Index Scan using estado_mantto_pkey on estado_mantto em  (cost=0.15..8.17 rows=1 width=62) (actual time=0.007..0.007 rows=1 loops=1)"
    "                                Index Cond: (id_estado = m.id_estado)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.003..0.003 rows=1 loops=1)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.005..0.005 rows=1 loops=1)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.362 ms"
    "Execution Time: 0.087 ms"
```

* Implementación del índice:

```sql
    CREATE INDEX IDX_Fecha_program
    ON Mantenimiento(fecha_inicio_programado)
```

* Plan de ejecución luego de implementar el índice:

```sql
    "Limit  (cost=33.22..33.22 rows=1 width=326) (actual time=0.059..0.059 rows=1 loops=1)"
    "  ->  Sort  (cost=33.22..33.22 rows=1 width=326) (actual time=0.058..0.058 rows=1 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=1.00..33.21 rows=1 width=326) (actual time=0.053..0.054 rows=1 loops=1)"
    "              ->  Nested Loop  (cost=0.85..32.98 rows=1 width=152) (actual time=0.044..0.045 rows=1 loops=1)"
    "                    ->  Nested Loop  (cost=0.70..24.79 rows=1 width=78) (actual time=0.038..0.039 rows=1 loops=1)"
    "                          ->  Nested Loop  (cost=0.55..16.60 rows=1 width=24) (actual time=0.033..0.034 rows=1 loops=1)"
    "                                ->  Index Scan using idx_fecha_program on mantenimiento m  (cost=0.28..8.29 rows=1 width=20) (actual time=0.027..0.027 rows=1 loops=1)"
    "                                      Index Cond: (fecha_inicio_programado = '2023-08-15'::date)"
    "                                ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.005..0.005 rows=1 loops=1)"
    "                                      Index Cond: (id_plan = m.id_plan)"
    "                          ->  Index Scan using estado_mantto_pkey on estado_mantto em  (cost=0.15..8.17 rows=1 width=62) (actual time=0.005..0.005 rows=1 loops=1)"
    "                                Index Cond: (id_estado = m.id_estado)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.005..0.005 rows=1 loops=1)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.005..0.005 rows=1 loops=1)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 1.346 ms"
    "Execution Time: 0.064 ms"
```

* Comparación de tiempos de ejecución

	- Sin índice, el tiempo de ejecución fue de 0.087 ms.
	- Con el índice, el tiempo de ejecución fue de 0.064 ms.
	- Esto muestra una mejora del 26.4% en el tiempo de ejecución.

* Comparación de costos

	- Sin índice, el costo fue de 33.22.
	- Con el índice, el costo fue de 33.22.
	- Esto muestra que el costo no cambió drásticamente.

### 3. Gestión de insumos
---
1) Índice para la búsqueda de reservas con su estado actual ordenadas por fecha y hora.
    
* Query utilizado:
    
    ```sql
    explain analyse
    SELECT r.Id_reserva, e.Nombre_estado
    FROM Reserva r
    JOIN Estado_reserva e ON e.Id_estado_reserva = r.Id_estado_reserva
    WHERE r.Id_estado_reserva <> 0 AND r.Id_estado_reserva <> 3
    ORDER BY Fecha, Hora
    LIMIT 10 OFFSET 0;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=10.01..10.03 rows=10 width=532) (actual time=0.194..0.198 rows=10 loops=1)"
    "  ->  Sort  (cost=10.01..10.16 rows=62 width=532) (actual time=0.192..0.194 rows=10 loops=1)"
    "        Sort Key: r.fecha, r.hora"
    "        Sort Method: top-N heapsort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.15..8.67 rows=62 width=532) (actual time=0.061..0.157 rows=57 loops=1)"
    "              ->  Seq Scan on reserva r  (cost=0.00..2.50 rows=62 width=20) (actual time=0.029..0.054 rows=57 loops=1)"
    "                    Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "                    Rows Removed by Filter: 43"
    "              ->  Memoize  (cost=0.15..0.95 rows=1 width=520) (actual time=0.001..0.001 rows=1 loops=57)"
    "                    Cache Key: r.id_estado_reserva"
    "                    Cache Mode: logical"
    "                    Hits: 55  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                    ->  Index Scan using estado_reserva_pkey on estado_reserva e  (cost=0.14..0.94 rows=1 width=520) (actual time=0.012..0.012 rows=1 loops=2)"
    "                          Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 3.166 ms"
    "Execution Time: 0.259 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_reserva_fecha_hora ON Reserva(Fecha, Hora);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=0.30..3.53 rows=10 width=532) (actual time=0.167..0.199 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=0.30..20.31 rows=62 width=532) (actual time=0.165..0.195 rows=10 loops=1)"
    "        ->  Index Scan using idx_reserva_fecha_hora on reserva r  (cost=0.14..14.14 rows=62 width=20) (actual time=0.114..0.123 rows=10 loops=1)"
    "              Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "              Rows Removed by Filter: 3"
    "        ->  Memoize  (cost=0.15..0.95 rows=1 width=520) (actual time=0.006..0.006 rows=1 loops=10)"
    "              Cache Key: r.id_estado_reserva"
    "              Cache Mode: logical"
    "              Hits: 8  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reserva_pkey on estado_reserva e  (cost=0.14..0.94 rows=1 width=520) (actual time=0.021..0.021 rows=1 loops=2)"
    "                    Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 2.717 ms"
    "Execution Time: 0.263 ms"
    ```

* Implementación de segundo índice en la misma consulta:

    ```sql
    CREATE INDEX idx_estado_reserva ON Estado_reserva(Id_estado_reserva);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=0.28..2.99 rows=10 width=532) (actual time=0.102..0.124 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=0.28..17.10 rows=62 width=532) (actual time=0.100..0.120 rows=10 loops=1)"
    "        ->  Index Scan using idx_reserva_fecha_hora on reserva r  (cost=0.14..14.14 rows=62 width=20) (actual time=0.015..0.021 rows=10 loops=1)"
    "              Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "              Rows Removed by Filter: 3"
    "        ->  Memoize  (cost=0.14..0.35 rows=1 width=520) (actual time=0.009..0.009 rows=1 loops=10)"
    "              Cache Key: r.id_estado_reserva"
    "              Cache Mode: logical"
    "              Hits: 8  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using idx_estado_reserva on estado_reserva e  (cost=0.13..0.34 rows=1 width=520) (actual time=0.038..0.038 rows=1 loops=2)"
    "                    Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 2.962 ms"
    "Execution Time: 0.187 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 10.01.
  - Luego de implementar el primer índice, el costo fue de 0.30.
  - Luego de implementar el segundo índice, el costo fue de 0.28.
  - Esto muestra una reducción del 97.2% en costo.


### 4. Gestión IPERC

### 5. Gestión de equipos de soporte

1) Índice para la busqueda de equipos de soporte según la disponibilidad del equipo

* Query utilizado:

    ```sql
    EXPLAIN ANALYZE
    SELECT
        es.id_equipo_soporte AS id,
        es.nombre_equipo_soporte AS nombre,
        ees.nombre_estado AS estado,
        tes.nombre_tipo AS tipo,
        es.horas_uso AS "horas uso",
        es.descripcion AS descripcion
    FROM equipo_de_soporte es
    INNER JOIN estado_equipo_soporte ees 
    ON ees.id_estado = es.id_estado
    INNER JOIN disponibilidad_equipo_soporte des 
    ON des.id_disponibilidad = es.id_disponibilidad
    INNER JOIN tipo_equipo_soporte tes 
    ON tes.id_tipo = es.id_tipo
    WHERE es.id_disponibilidad = 1
    ORDER BY es.id_equipo_soporte
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Sort  (cost=28.41..28.55 rows=57 width=586) (actual time=0.408..0.414 rows=57 loops=1)"
    "  Sort Key: es.id_equipo_soporte"
    "  Sort Method: quicksort  Memory: 35kB"
    "  ->  Nested Loop  (cost=0.46..26.74 rows=57 width=586) (actual time=0.197..0.341 rows=57 loops=1)"
    "        ->  Nested Loop  (cost=0.30..19.37 rows=57 width=372) (actual time=0.176..0.272 rows=57 loops=1)"
    "              ->  Index Only Scan using disponibilidad_equipo_soporte_pkey on disponibilidad_equipo_soporte des  (cost=0.15..8.17 rows=1 width=4) (actual time=0.112..0.114 rows=1 loops=1)"
    "                    Index Cond: (id_disponibilidad = 1)"
    "                    Heap Fetches: 1"
    "              ->  Nested Loop  (cost=0.16..10.63 rows=57 width=376) (actual time=0.061..0.145 rows=57 loops=1)"
    "                    ->  Seq Scan on equipo_de_soporte es  (cost=0.00..4.25 rows=57 width=162) (actual time=0.027..0.058 rows=57 loops=1)"
    "                          Filter: (id_disponibilidad = 1)"
    "                          Rows Removed by Filter: 43"
    "                    ->  Memoize  (cost=0.16..1.02 rows=1 width=222) (actual time=0.001..0.001 rows=1 loops=57)"
    "                          Cache Key: es.id_estado"
    "                          Cache Mode: logical"
    "                          Hits: 53  Misses: 4  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using estado_equipo_soporte_pkey on estado_equipo_soporte ees  (cost=0.15..1.01 rows=1 width=222) (actual time=0.007..0.007 rows=1 loops=4)"
    "                                Index Cond: (id_estado = es.id_estado)"
    "        ->  Memoize  (cost=0.16..1.02 rows=1 width=222) (actual time=0.001..0.001 rows=1 loops=57)"
    "              Cache Key: es.id_tipo"
    "              Cache Mode: logical"
    "              Hits: 52  Misses: 5  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using tipo_equipo_soporte_pkey on tipo_equipo_soporte tes  (cost=0.15..1.01 rows=1 width=222) (actual time=0.005..0.005 rows=1 loops=5)"
    "                    Index Cond: (id_tipo = es.id_tipo)"
    "Planning Time: 7.892 ms"
    "Execution Time: 0.508 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_disponibilidad_equipo ON Equipo_de_soporte(id_disponibilidad);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Sort  (cost=20.41..20.55 rows=57 width=586) (actual time=0.238..0.242 rows=57 loops=1)"
    "  Sort Key: es.id_equipo_soporte"
    "  Sort Method: quicksort  Memory: 35kB"
    "  ->  Nested Loop  (cost=0.46..26.74 rows=57 width=586) (actual time=0.071..0.197 rows=57 loops=1)"
    "        ->  Nested Loop  (cost=0.30..19.37 rows=57 width=372) (actual time=0.061..0.143 rows=57 loops=1)"
    "              ->  Index Only Scan using disponibilidad_equipo_soporte_pkey on disponibilidad_equipo_soporte des  (cost=0.15..8.17 rows=1 width=4) (actual time=0.017..0.018 rows=1 loops=1)"
    "                    Index Cond: (id_disponibilidad = 1)"
    "                    Heap Fetches: 1"
    "              ->  Nested Loop  (cost=0.16..10.63 rows=57 width=376) (actual time=0.042..0.114 rows=57 loops=1)"
    "                    ->  Seq Scan on equipo_de_soporte es  (cost=0.00..4.25 rows=57 width=162) (actual time=0.025..0.047 rows=57 loops=1)"
    "                          Filter: (id_disponibilidad = 1)"
    "                          Rows Removed by Filter: 43"
    "                    ->  Memoize  (cost=0.16..1.02 rows=1 width=222) (actual time=0.001..0.001 rows=1 loops=57)"
    "                          Cache Key: es.id_estado"
    "                          Cache Mode: logical"
    "                          Hits: 53  Misses: 4  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using estado_equipo_soporte_pkey on estado_equipo_soporte ees  (cost=0.15..1.01 rows=1 width=222) (actual time=0.003..0.003 rows=1 loops=4)"
    "                                Index Cond: (id_estado = es.id_estado)"
    "        ->  Memoize  (cost=0.16..1.02 rows=1 width=222) (actual time=0.001..0.001 rows=1 loops=57)"
    "              Cache Key: es.id_tipo"
    "              Cache Mode: logical"
    "              Hits: 52  Misses: 5  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using tipo_equipo_soporte_pkey on tipo_equipo_soporte tes  (cost=0.15..1.01 rows=1 width=222) (actual time=0.003..0.003 rows=1 loops=5)"
    "                    Index Cond: (id_tipo = es.id_tipo)"
    "Planning Time: 2.313 ms"
    "Execution Time: 0.326 ms"
    ```

* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 28.55.
  - Luego de implementar, el costo nuevo es 20.55.
  - Esto muestra una reducción del 28.02% en costo.

---
2) Índice para la busqueda de pedidos de compra de equipos de soporte según el estado del pedido

* Query utilizado:

    ```sql
    EXPLAIN ANALYZE
    SELECT
        pc.id_pedido_compra AS id,
        e.nombre AS nombre,
        tu.tipo_urgencia AS urgencia,
        ep.nombre_estado_pedido AS estado,
        tp.nombre_tipo_producto AS tipo
    FROM pedido_compra pc
    INNER JOIN empleado e
    ON e.id_empleado = pc.id_empleado
    INNER JOIN tipo_urgencia tu
    ON tu.id_urgencia = pc.id_urgencia
    INNER JOIN estado_pedido ep
    ON ep.id_estado_pedido = pc.id_estado_pedido
    INNER JOIN tipo_producto tp
    ON tp.id_tipo_producto = pc.id_tipo_producto
    WHERE pc.id_estado_pedido = 1
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Nested Loop  (cost=42.96..69.97 rows=34 width=1567) (actual time=0.581..0.671 rows=34 loops=1)"
    "  ->  Nested Loop  (cost=42.80..64.50 rows=34 width=1055) (actual time=0.551..0.626 rows=34 loops=1)"
    "        ->  Index Scan using estado_pedido_pkey on estado_pedido ep  (cost=0.14..8.16 rows=1 width=520) (actual time=0.036..0.041 rows=1 loops=1)"
    "              Index Cond: (id_estado_pedido = 1)"
    "        ->  Nested Loop  (cost=42.66..56.00 rows=34 width=543) (actual time=0.510..0.577 rows=34 loops=1)"
    "              ->  Hash Join  (cost=42.50..47.46 rows=34 width=31) (actual time=0.452..0.497 rows=34 loops=1)"
    "                    Hash Cond: (pc.id_empleado = e.id_empleado)"
    "                    ->  Seq Scan on pedido_compra pc  (cost=0.00..4.88 rows=34 width=20) (actual time=0.024..0.049 rows=34 loops=1)"
    "                          Filter: (id_estado_pedido = 1)"
    "                          Rows Removed by Filter: 116"
    "                    ->  Hash  (cost=30.00..30.00 rows=1000 width=19) (actual time=0.406..0.407 rows=1000 loops=1)"
    "                          Buckets: 1024  Batches: 1  Memory Usage: 60kB"
    "                          ->  Seq Scan on empleado e  (cost=0.00..30.00 rows=1000 width=19) (actual time=0.008..0.207 rows=1000 loops=1)"
    "              ->  Memoize  (cost=0.15..1.58 rows=1 width=520) (actual time=0.002..0.002 rows=1 loops=34)"
    "                    Cache Key: pc.id_urgencia"
    "                    Cache Mode: logical"
    "                    Hits: 30  Misses: 4  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                    ->  Index Scan using tipo_urgencia_pkey on tipo_urgencia tu  (cost=0.14..1.57 rows=1 width=520) (actual time=0.011..0.011 rows=1 loops=4)"
    "                          Index Cond: (id_urgencia = pc.id_urgencia)"
    "  ->  Memoize  (cost=0.15..1.58 rows=1 width=520) (actual time=0.001..0.001 rows=1 loops=34)"
    "        Cache Key: pc.id_tipo_producto"
    "        Cache Mode: logical"
    "        Hits: 32  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "        ->  Index Scan using tipo_producto_pkey on tipo_producto tp  (cost=0.14..1.57 rows=1 width=520) (actual time=0.012..0.012 rows=1 loops=2)"
    "              Index Cond: (id_tipo_producto = pc.id_tipo_producto)"
    "Planning Time: 0.644 ms"
    "Execution Time: 0.815 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_estado_pedido ON pedido_compra(id_estado_pedido);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Nested Loop  (cost=38.86..49.45 rows=34 width=1567) (actual time=0.391..0.464 rows=34 loops=1)"
    "  ->  Nested Loop  (cost=42.80..64.50 rows=34 width=1055) (actual time=0.378..0.435 rows=34 loops=1)"
    "        ->  Index Scan using estado_pedido_pkey on estado_pedido ep  (cost=0.14..8.16 rows=1 width=520) (actual time=0.013..0.014 rows=1 loops=1)"
    "              Index Cond: (id_estado_pedido = 1)"
    "        ->  Nested Loop  (cost=42.66..56.00 rows=34 width=543) (actual time=0.362..0.415 rows=34 loops=1)"
    "              ->  Hash Join  (cost=42.50..47.46 rows=34 width=31) (actual time=0.345..0.378 rows=34 loops=1)"
    "                    Hash Cond: (pc.id_empleado = e.id_empleado)"
    "                    ->  Seq Scan on pedido_compra pc  (cost=0.00..4.88 rows=34 width=20) (actual time=0.021..0.043 rows=34 loops=1)"
    "                          Filter: (id_estado_pedido = 1)"
    "                          Rows Removed by Filter: 116"
    "                    ->  Hash  (cost=30.00..30.00 rows=1000 width=19) (actual time=0.314..0.314 rows=1000 loops=1)"
    "                          Buckets: 1024  Batches: 1  Memory Usage: 60kB"
    "                          ->  Seq Scan on empleado e  (cost=0.00..30.00 rows=1000 width=19) (actual time=0.010..0.170 rows=1000 loops=1)"
    "              ->  Memoize  (cost=0.15..1.58 rows=1 width=520) (actual time=0.001..0.001 rows=1 loops=34)"
    "                    Cache Key: pc.id_urgencia"
    "                    Cache Mode: logical"
    "                    Hits: 30  Misses: 4  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                    ->  Index Scan using tipo_urgencia_pkey on tipo_urgencia tu  (cost=0.14..1.57 rows=1 width=520) (actual time=0.004..0.004 rows=1 loops=4)"
    "                          Index Cond: (id_urgencia = pc.id_urgencia)"
    "  ->  Memoize  (cost=0.15..1.58 rows=1 width=520) (actual time=0.001..0.001 rows=1 loops=34)"
    "        Cache Key: pc.id_tipo_producto"
    "        Cache Mode: logical"
    "        Hits: 32  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "        ->  Index Scan using tipo_producto_pkey on tipo_producto tp  (cost=0.14..1.57 rows=1 width=520) (actual time=0.006..0.007 rows=1 loops=2)"
    "              Index Cond: (id_tipo_producto = pc.id_tipo_producto)"
    "Planning Time: 9.463 ms"
    "Execution Time: 0.565 ms"
    ```

* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 42.96.
  - Luego de implementar, el costo nuevo es 38.86.
  - Esto muestra una reducción del 9.54% en costo.
---

### 6. Seguridad

### 7. Gestión de reportes e historial de mantenimiento
---
1) Indice para la busqueda de Registros mediante la fecha del registro

* Query Utilizado:

    ```sql
    EXPLAIN ANALYSE
    SELECT 
    'R' || TO_CHAR(rep.Fecha_reporte, 'YYYYMMDD') AS Codigo_Registro,
    rep.Fecha_reporte::date AS Fecha_del_Dia,
    registros_por_dia.total,
    rep.Fecha_reporte,
    est.nombre_estado AS "Estado_Reporte",
    rep.id_jefe
    FROM  
        reportes rep
    INNER JOIN 
        (SELECT 
            fecha_registro::date AS fecha_del_dia, 
            COUNT(*) AS total 
        FROM registro
        WHERE fecha_inicial BETWEEN '2024-05-12' AND '2024-12-10'
        GROUP BY fecha_registro::date) AS registros_por_dia
    ON rep.fecha_reporte::date = registros_por_dia.fecha_del_dia

    JOIN 
    Estado_Reporte AS est ON rep.id_estado_reporte = est.id_estado_reporte
    ORDER BY rep.fecha_reporte::date
    LIMIT 10 OFFSET 0;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=72.23..73.08 rows=10 width=568) (actual time=1.876..1.895 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=72.23..93.73 rows=253 width=568) (actual time=1.875..1.893 rows=10 loops=1)"
    "        ->  Merge Join  (cost=72.08..84.54 rows=253 width=20) (actual time=1.182..1.191 rows=10 loops=1)"
    "              Merge Cond: (((registro.fecha_registro)::date) = rep.fecha_reporte)"
    "              ->  GroupAggregate  (cost=52.01..57.39 rows=253 width=12) (actual time=0.278..0.310 rows=129 loops=1)"
    "                    Group Key: ((registro.fecha_registro)::date)"
    "                    ->  Sort  (cost=52.01..52.75 rows=296 width=4) (actual time=0.273..0.278 rows=161 loops=1)"
    "                          Sort Key: ((registro.fecha_registro)::date)"
    "                          Sort Method: quicksort  Memory: 25kB"
    "                          ->  Seq Scan on registro  (cost=0.00..39.86 rows=296 width=4) (actual time=0.114..0.210 rows=299 loops=1)"
    "                                Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                Rows Removed by Filter: 709"
    "              ->  Sort  (cost=20.07..20.76 rows=278 width=12) (actual time=0.869..0.871 rows=29 loops=1)"
    "                    Sort Key: rep.fecha_reporte"
    "                    Sort Method: quicksort  Memory: 35kB"
    "                    ->  Seq Scan on reportes rep  (cost=0.00..8.78 rows=278 width=12) (actual time=0.008..0.037 rows=278 loops=1)"
    "        ->  Memoize  (cost=0.15..0.35 rows=1 width=520) (actual time=0.003..0.003 rows=1 loops=10)"
    "              Cache Key: rep.id_estado_reporte"
    "              Cache Mode: logical"
    "              Hits: 9  Misses: 1  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reporte_pkey on estado_reporte est  (cost=0.14..0.34 rows=1 width=520) (actual time=0.026..0.026 rows=1 loops=1)"
    "                    Index Cond: (id_estado_reporte = rep.id_estado_reporte)"
    "Planning Time: 2.393 ms"
    "Execution Time: 2.065 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_registros_fecha ON Registro(Fecha_inicial, fecha_registro);
    CREATE INDEX idx_reportes_fecha ON reportes (fecha_reporte);
    ```

* Plan de ejecución luego de ejecutar el indice:

    ```sql
    "Limit  (cost=52.31..54.42 rows=10 width=568) (actual time=0.403..0.436 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=52.31..105.52 rows=253 width=568) (actual time=0.402..0.434 rows=10 loops=1)"
    "        ->  Merge Join  (cost=52.16..96.33 rows=253 width=20) (actual time=0.368..0.388 rows=10 loops=1)"
    "              Merge Cond: (rep.fecha_reporte = ((registro.fecha_registro)::date))"
    "              ->  Index Scan using idx_reportes_fecha_reporte on reportes rep  (cost=0.15..32.55 rows=278 width=12) (actual time=0.071..0.082 rows=29 loops=1)"
    "              ->  GroupAggregate  (cost=52.01..57.39 rows=253 width=12) (actual time=0.220..0.289 rows=129 loops=1)"
    "                    Group Key: ((registro.fecha_registro)::date)"
    "                    ->  Sort  (cost=52.01..52.75 rows=296 width=4) (actual time=0.214..0.223 rows=161 loops=1)"
    "                          Sort Key: ((registro.fecha_registro)::date)"
    "                          Sort Method: quicksort  Memory: 25kB"
    "                          ->  Seq Scan on registro  (cost=0.00..39.86 rows=296 width=4) (actual time=0.013..0.162 rows=299 loops=1)"
    "                                Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                Rows Removed by Filter: 709"
    "        ->  Memoize  (cost=0.15..0.35 rows=1 width=520) (actual time=0.003..0.003 rows=1 loops=10)"
    "              Cache Key: rep.id_estado_reporte"
    "              Cache Mode: logical"
    "              Hits: 9  Misses: 1  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reporte_pkey on estado_reporte est  (cost=0.14..0.34 rows=1 width=520) (actual time=0.021..0.022 rows=1 loops=1)"
    "                    Index Cond: (id_estado_reporte = rep.id_estado_reporte)"
    "Planning Time: 1.822 ms"
    "Execution Time: 0.544 ms"
    ```

* Comparación de tiempos de ejecución:

    - Sin índice, el tiempo de ejecución fue de 2.065 ms.
    - Con el índice, el tiempo de ejecución fue de 0.544 ms.
    - Esto muestra una mejora del 73.6% en el tiempo de ejecución.
* Comparación de costos:

    - Sin índice, el costo fue de 73.08.
    - Con el índice, el costo fue de 54.42.
    - Esto muestra una reducción del 25.9% en el costo.
