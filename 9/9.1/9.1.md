# 9.1. Índices

## Módulos

### 1. Planificación del mantenimiento:
   
1) Índice para la búsqueda de planes de mantenimiento según la máquina a reparar:
    
* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.id_maquina = 8
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=62.13..62.14 rows=3 width=268) (actual time=0.173..0.174 rows=3 loops=1)"
    "  ->  Sort  (cost=62.13..62.14 rows=3 width=268) (actual time=0.171..0.172 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.59..62.11 rows=3 width=268) (actual time=0.056..0.164 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=0.44..61.41 rows=3 width=94) (actual time=0.043..0.147 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..45.39 rows=3 width=20) (actual time=0.033..0.133 rows=3 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=3 width=16) (actual time=0.022..0.117 rows=3 loops=1)"
    "                                Filter: (id_maquina = 8)"
    "                                Rows Removed by Filter: 997"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.003..0.003 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.674 ms"
    "Execution Time: 0.659 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Maquina_mantto
    ON Mantenimiento(id_maquina);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=52.46..52.46 rows=3 width=268) (actual time=0.129..0.131 rows=3 loops=1)"
    "  ->  Sort  (cost=52.46..52.46 rows=3 width=268) (actual time=0.127..0.129 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=4.88..52.43 rows=3 width=268) (actual time=0.097..0.119 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=4.73..51.73 rows=3 width=94) (actual time=0.082..0.098 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=4.57..35.72 rows=3 width=20) (actual time=0.070..0.080 rows=3 loops=1)"
    "                          ->  Bitmap Heap Scan on mantenimiento m  (cost=4.30..10.82 rows=3 width=16) (actual time=0.058..0.061 rows=3 loops=1)"
    "                                Recheck Cond: (id_maquina = 8)"
    "                                Heap Blocks: exact=2"
    "                                ->  Bitmap Index Scan on idx_maquina_mantto  (cost=0.00..4.30 rows=3 width=0) (actual time=0.052..0.052 rows=3 loops=1)"
    "                                      Index Cond: (id_maquina = 8)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.005..0.005 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 2.329 ms"
    "Execution Time: 0.232 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 62.14.
  - Luego de implementar, el costo nuevo es 52.46.
  - Esto muestra una reducción del 15.58% en costo.

1) Índice para la búsqueda de planes de mantenimiento según la fecha de inicio programada:

* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.fecha_inicio_programado = DATE('2023-07-17')
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=37.24..37.25 rows=1 width=268) (actual time=0.293..0.294 rows=2 loops=1)"
    "  ->  Sort  (cost=37.24..37.25 rows=1 width=268) (actual time=0.273..0.274 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.58..37.23 rows=1 width=268) (actual time=0.181..0.250 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.43..37.00 rows=1 width=94) (actual time=0.154..0.219 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..28.81 rows=1 width=20) (actual time=0.136..0.198 rows=2 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=1 width=16) (actual time=0.110..0.166 rows=2 loops=1)"
    "                                Filter: (fecha_inicio_programado = '2023-07-17'::date)"
    "                                Rows Removed by Filter: 998"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.012..0.012 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.008..0.008 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.441 ms"
    "Execution Time: 0.367 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Fecha_mantto
    ON Mantenimiento(fecha_inicio_programado)
    ```

    * Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=25.03..25.04 rows=1 width=268) (actual time=0.112..0.113 rows=2 loops=1)"
    "  ->  Sort  (cost=25.03..25.04 rows=1 width=268) (actual time=0.111..0.112 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.85..25.02 rows=1 width=268) (actual time=0.085..0.094 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.70..24.79 rows=1 width=94) (actual time=0.069..0.075 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.55..16.60 rows=1 width=20) (actual time=0.060..0.065 rows=2 loops=1)"
    "                          ->  Index Scan using idx_fecha_mantto on mantenimiento m  (cost=0.28..8.29 rows=1 width=16) (actual time=0.048..0.049 rows=2 loops=1)"
    "                                Index Cond: (fecha_inicio_programado = '2023-07-17'::date)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.006..0.006 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 1.762 ms"
    "Execution Time: 0.155 ms"
    ```

* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 37.25.
  - Luego de implementar el índice, el costo nuevo es 25.04.
  - Esto muestra una reducción del 32.78% en costo.

---

### 2. Control del mantenimiento

### 3. Gestión de equipos de soporte

### 4. Gestión del IPERC

### 5. Gestión de insumos

### 6. Seguridad

### 7. Gestión de reportes e historial de mantenimiento
