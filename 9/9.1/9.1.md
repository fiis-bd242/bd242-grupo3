# 9.1. Índices

## Módulos

### 1. Planificación del mantenimiento:
   
1) Índice para la búsqueda de planes de mantenimiento según la máquina a reparar:
    
* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.id_maquina = 8
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=62.13..62.14 rows=3 width=268) (actual time=0.173..0.174 rows=3 loops=1)"
    "  ->  Sort  (cost=62.13..62.14 rows=3 width=268) (actual time=0.171..0.172 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.59..62.11 rows=3 width=268) (actual time=0.056..0.164 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=0.44..61.41 rows=3 width=94) (actual time=0.043..0.147 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..45.39 rows=3 width=20) (actual time=0.033..0.133 rows=3 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=3 width=16) (actual time=0.022..0.117 rows=3 loops=1)"
    "                                Filter: (id_maquina = 8)"
    "                                Rows Removed by Filter: 997"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.003..0.003 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.674 ms"
    "Execution Time: 0.659 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Maquina_mantto
    ON Mantenimiento(id_maquina);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=52.46..52.46 rows=3 width=268) (actual time=0.129..0.131 rows=3 loops=1)"
    "  ->  Sort  (cost=52.46..52.46 rows=3 width=268) (actual time=0.127..0.129 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=4.88..52.43 rows=3 width=268) (actual time=0.097..0.119 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=4.73..51.73 rows=3 width=94) (actual time=0.082..0.098 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=4.57..35.72 rows=3 width=20) (actual time=0.070..0.080 rows=3 loops=1)"
    "                          ->  Bitmap Heap Scan on mantenimiento m  (cost=4.30..10.82 rows=3 width=16) (actual time=0.058..0.061 rows=3 loops=1)"
    "                                Recheck Cond: (id_maquina = 8)"
    "                                Heap Blocks: exact=2"
    "                                ->  Bitmap Index Scan on idx_maquina_mantto  (cost=0.00..4.30 rows=3 width=0) (actual time=0.052..0.052 rows=3 loops=1)"
    "                                      Index Cond: (id_maquina = 8)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.005..0.005 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 2.329 ms"
    "Execution Time: 0.232 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 62.14.
  - Luego de implementar, el costo nuevo es 52.46.
  - Esto muestra una reducción del 15.58% en costo.

2) Índice para la búsqueda de planes de mantenimiento según la fecha de inicio programada:

* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.fecha_inicio_programado = DATE('2023-07-17')
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=37.24..37.25 rows=1 width=268) (actual time=0.293..0.294 rows=2 loops=1)"
    "  ->  Sort  (cost=37.24..37.25 rows=1 width=268) (actual time=0.273..0.274 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.58..37.23 rows=1 width=268) (actual time=0.181..0.250 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.43..37.00 rows=1 width=94) (actual time=0.154..0.219 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..28.81 rows=1 width=20) (actual time=0.136..0.198 rows=2 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=1 width=16) (actual time=0.110..0.166 rows=2 loops=1)"
    "                                Filter: (fecha_inicio_programado = '2023-07-17'::date)"
    "                                Rows Removed by Filter: 998"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.012..0.012 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.008..0.008 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.441 ms"
    "Execution Time: 0.367 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Fecha_mantto
    ON Mantenimiento(fecha_inicio_programado)
    ```

    * Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=25.03..25.04 rows=1 width=268) (actual time=0.112..0.113 rows=2 loops=1)"
    "  ->  Sort  (cost=25.03..25.04 rows=1 width=268) (actual time=0.111..0.112 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.85..25.02 rows=1 width=268) (actual time=0.085..0.094 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.70..24.79 rows=1 width=94) (actual time=0.069..0.075 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.55..16.60 rows=1 width=20) (actual time=0.060..0.065 rows=2 loops=1)"
    "                          ->  Index Scan using idx_fecha_mantto on mantenimiento m  (cost=0.28..8.29 rows=1 width=16) (actual time=0.048..0.049 rows=2 loops=1)"
    "                                Index Cond: (fecha_inicio_programado = '2023-07-17'::date)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.006..0.006 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 1.762 ms"
    "Execution Time: 0.155 ms"
    ```

* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 37.25.
  - Luego de implementar el índice, el costo nuevo es 25.04.
  - Esto muestra una reducción del 32.78% en costo.

---

### 2. Control del mantenimiento

Índice para la busqueda de la orden de trabajo segun la fecha en que fue programada

* Query utilizado:

```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
                CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
                tm.nombre_tipo_mant,
                c.nivel,
                m.fecha_inicio_programado,
                em.estado
                FROM Plan_de_Mantenimiento p
                INNER JOIN Mantenimiento m
                ON m.id_plan = p.id_plan
                INNER JOIN estado_mantto em
                ON em.id_estado = m.id_estado
                INNER JOIN Tipo_mantenimiento tm
                ON tm.id_tipo_mant = m.id_tipo_mant
                INNER JOIN Criticidad c
                ON c.id_criticidad = p.id_criticidad
		WHERE m.fecha_inicio_programado = DATE('2023-08-15')
                ORDER BY p.id_plan
                LIMIT 9
                OFFSET 1-1;
```

* Plan de ejecución antes de implementar el índice:

```sql
    "Limit  (cost=33.22..33.22 rows=1 width=326) (actual time=0.038..0.039 rows=1 loops=1)"
    "  ->  Sort  (cost=33.22..33.22 rows=1 width=326) (actual time=0.037..0.038 rows=1 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=1.00..33.21 rows=1 width=326) (actual time=0.032..0.033 rows=1 loops=1)"
    "              ->  Nested Loop  (cost=0.85..32.98 rows=1 width=152) (actual time=0.024..0.025 rows=1 loops=1)"
    "                    ->  Nested Loop  (cost=0.70..24.79 rows=1 width=78) (actual time=0.021..0.022 rows=1 loops=1)"
    "                          ->  Nested Loop  (cost=0.55..16.60 rows=1 width=24) (actual time=0.013..0.014 rows=1 loops=1)"
    "                                ->  Index Scan using idx_fecha_programada on mantenimiento m  (cost=0.28..8.29 rows=1 width=20) (actual time=0.005..0.005 rows=1 loops=1)"
    "                                      Index Cond: (fecha_inicio_programado = '2023-08-15'::date)"
    "                                ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.007..0.007 rows=1 loops=1)"
    "                                      Index Cond: (id_plan = m.id_plan)"
    "                          ->  Index Scan using estado_mantto_pkey on estado_mantto em  (cost=0.15..8.17 rows=1 width=62) (actual time=0.007..0.007 rows=1 loops=1)"
    "                                Index Cond: (id_estado = m.id_estado)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.003..0.003 rows=1 loops=1)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.005..0.005 rows=1 loops=1)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.362 ms"
    "Execution Time: 0.087 ms"
```

* Implementación del índice:

```sql
    CREATE INDEX IDX_Fecha_program
    ON Mantenimiento(fecha_inicio_programado)
```

* Plan de ejecución luego de implementar el índice:

```sql
    "Limit  (cost=33.22..33.22 rows=1 width=326) (actual time=0.059..0.059 rows=1 loops=1)"
    "  ->  Sort  (cost=33.22..33.22 rows=1 width=326) (actual time=0.058..0.058 rows=1 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=1.00..33.21 rows=1 width=326) (actual time=0.053..0.054 rows=1 loops=1)"
    "              ->  Nested Loop  (cost=0.85..32.98 rows=1 width=152) (actual time=0.044..0.045 rows=1 loops=1)"
    "                    ->  Nested Loop  (cost=0.70..24.79 rows=1 width=78) (actual time=0.038..0.039 rows=1 loops=1)"
    "                          ->  Nested Loop  (cost=0.55..16.60 rows=1 width=24) (actual time=0.033..0.034 rows=1 loops=1)"
    "                                ->  Index Scan using idx_fecha_program on mantenimiento m  (cost=0.28..8.29 rows=1 width=20) (actual time=0.027..0.027 rows=1 loops=1)"
    "                                      Index Cond: (fecha_inicio_programado = '2023-08-15'::date)"
    "                                ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.005..0.005 rows=1 loops=1)"
    "                                      Index Cond: (id_plan = m.id_plan)"
    "                          ->  Index Scan using estado_mantto_pkey on estado_mantto em  (cost=0.15..8.17 rows=1 width=62) (actual time=0.005..0.005 rows=1 loops=1)"
    "                                Index Cond: (id_estado = m.id_estado)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.005..0.005 rows=1 loops=1)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.005..0.005 rows=1 loops=1)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 1.346 ms"
    "Execution Time: 0.064 ms"
```

* Comparación de tiempos de ejecución

	- Sin índice, el tiempo de ejecución fue de 0.087 ms.
	- Con el índice, el tiempo de ejecución fue de 0.064 ms.
	- Esto muestra una mejora del 26.4% en el tiempo de ejecución.

* Comparación de costos

	- Sin índice, el costo fue de 33.22.
	- Con el índice, el costo fue de 33.22.
	- Esto muestra que el costo no cambió drásticamente.



### 3. Gestión de equipos de soporte

### 4. Gestión del IPERC

### 5. Gestión de insumos
---
1) Índice para la búsqueda de reservas con su estado actual ordenadas por fecha y hora.
    
* Query utilizado:
    
    ```sql
    explain analyse
    SELECT r.Id_reserva, e.Nombre_estado
    FROM Reserva r
    JOIN Estado_reserva e ON e.Id_estado_reserva = r.Id_estado_reserva
    WHERE r.Id_estado_reserva <> 0 AND r.Id_estado_reserva <> 3
    ORDER BY Fecha, Hora
    LIMIT 10 OFFSET 0;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=10.01..10.03 rows=10 width=532) (actual time=0.194..0.198 rows=10 loops=1)"
    "  ->  Sort  (cost=10.01..10.16 rows=62 width=532) (actual time=0.192..0.194 rows=10 loops=1)"
    "        Sort Key: r.fecha, r.hora"
    "        Sort Method: top-N heapsort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.15..8.67 rows=62 width=532) (actual time=0.061..0.157 rows=57 loops=1)"
    "              ->  Seq Scan on reserva r  (cost=0.00..2.50 rows=62 width=20) (actual time=0.029..0.054 rows=57 loops=1)"
    "                    Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "                    Rows Removed by Filter: 43"
    "              ->  Memoize  (cost=0.15..0.95 rows=1 width=520) (actual time=0.001..0.001 rows=1 loops=57)"
    "                    Cache Key: r.id_estado_reserva"
    "                    Cache Mode: logical"
    "                    Hits: 55  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                    ->  Index Scan using estado_reserva_pkey on estado_reserva e  (cost=0.14..0.94 rows=1 width=520) (actual time=0.012..0.012 rows=1 loops=2)"
    "                          Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 3.166 ms"
    "Execution Time: 0.259 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_reserva_fecha_hora ON Reserva(Fecha, Hora);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=0.30..3.53 rows=10 width=532) (actual time=0.167..0.199 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=0.30..20.31 rows=62 width=532) (actual time=0.165..0.195 rows=10 loops=1)"
    "        ->  Index Scan using idx_reserva_fecha_hora on reserva r  (cost=0.14..14.14 rows=62 width=20) (actual time=0.114..0.123 rows=10 loops=1)"
    "              Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "              Rows Removed by Filter: 3"
    "        ->  Memoize  (cost=0.15..0.95 rows=1 width=520) (actual time=0.006..0.006 rows=1 loops=10)"
    "              Cache Key: r.id_estado_reserva"
    "              Cache Mode: logical"
    "              Hits: 8  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reserva_pkey on estado_reserva e  (cost=0.14..0.94 rows=1 width=520) (actual time=0.021..0.021 rows=1 loops=2)"
    "                    Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 2.717 ms"
    "Execution Time: 0.263 ms"
    ```

* Implementación de segundo índice en la misma consulta:

    ```sql
    CREATE INDEX idx_estado_reserva ON Estado_reserva(Id_estado_reserva);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=0.28..2.99 rows=10 width=532) (actual time=0.102..0.124 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=0.28..17.10 rows=62 width=532) (actual time=0.100..0.120 rows=10 loops=1)"
    "        ->  Index Scan using idx_reserva_fecha_hora on reserva r  (cost=0.14..14.14 rows=62 width=20) (actual time=0.015..0.021 rows=10 loops=1)"
    "              Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "              Rows Removed by Filter: 3"
    "        ->  Memoize  (cost=0.14..0.35 rows=1 width=520) (actual time=0.009..0.009 rows=1 loops=10)"
    "              Cache Key: r.id_estado_reserva"
    "              Cache Mode: logical"
    "              Hits: 8  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using idx_estado_reserva on estado_reserva e  (cost=0.13..0.34 rows=1 width=520) (actual time=0.038..0.038 rows=1 loops=2)"
    "                    Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 2.962 ms"
    "Execution Time: 0.187 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 10.01.
  - Luego de implementar el primer índice, el costo fue de 0.30.
  - Luego de implementar el segundo índice, el costo fue de 0.28.
  - Esto muestra una reducción del 97.2% en costo.

---
### 6. Seguridad

### 7. Gestión de reportes e historial de mantenimiento
---
1) Indice para la busqueda de Registros mediante la fecha del registro

* Query Utilizado:

    ```sql
    EXPLAIN ANALYSE
    SELECT 
    'R' || TO_CHAR(rep.Fecha_reporte, 'YYYYMMDD') AS Codigo_Registro,
    rep.Fecha_reporte::date AS Fecha_del_Dia,
    registros_por_dia.total,
    rep.Fecha_reporte,
    est.nombre_estado AS "Estado_Reporte",
    rep.id_jefe
    FROM  
        reportes rep
    INNER JOIN 
        (SELECT 
            fecha_registro::date AS fecha_del_dia, 
            COUNT(*) AS total 
        FROM registro
        WHERE fecha_inicial BETWEEN '2024-05-12' AND '2024-12-10'
        GROUP BY fecha_registro::date) AS registros_por_dia
    ON rep.fecha_reporte::date = registros_por_dia.fecha_del_dia

    JOIN 
    Estado_Reporte AS est ON rep.id_estado_reporte = est.id_estado_reporte
    ORDER BY rep.fecha_reporte::date
    LIMIT 10 OFFSET 0;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=72.23..73.08 rows=10 width=568) (actual time=1.876..1.895 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=72.23..93.73 rows=253 width=568) (actual time=1.875..1.893 rows=10 loops=1)"
    "        ->  Merge Join  (cost=72.08..84.54 rows=253 width=20) (actual time=1.182..1.191 rows=10 loops=1)"
    "              Merge Cond: (((registro.fecha_registro)::date) = rep.fecha_reporte)"
    "              ->  GroupAggregate  (cost=52.01..57.39 rows=253 width=12) (actual time=0.278..0.310 rows=129 loops=1)"
    "                    Group Key: ((registro.fecha_registro)::date)"
    "                    ->  Sort  (cost=52.01..52.75 rows=296 width=4) (actual time=0.273..0.278 rows=161 loops=1)"
    "                          Sort Key: ((registro.fecha_registro)::date)"
    "                          Sort Method: quicksort  Memory: 25kB"
    "                          ->  Seq Scan on registro  (cost=0.00..39.86 rows=296 width=4) (actual time=0.114..0.210 rows=299 loops=1)"
    "                                Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                Rows Removed by Filter: 709"
    "              ->  Sort  (cost=20.07..20.76 rows=278 width=12) (actual time=0.869..0.871 rows=29 loops=1)"
    "                    Sort Key: rep.fecha_reporte"
    "                    Sort Method: quicksort  Memory: 35kB"
    "                    ->  Seq Scan on reportes rep  (cost=0.00..8.78 rows=278 width=12) (actual time=0.008..0.037 rows=278 loops=1)"
    "        ->  Memoize  (cost=0.15..0.35 rows=1 width=520) (actual time=0.003..0.003 rows=1 loops=10)"
    "              Cache Key: rep.id_estado_reporte"
    "              Cache Mode: logical"
    "              Hits: 9  Misses: 1  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reporte_pkey on estado_reporte est  (cost=0.14..0.34 rows=1 width=520) (actual time=0.026..0.026 rows=1 loops=1)"
    "                    Index Cond: (id_estado_reporte = rep.id_estado_reporte)"
    "Planning Time: 2.393 ms"
    "Execution Time: 2.065 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_registros_fecha ON Registro(Fecha_inicial, fecha_registro);
    CREATE INDEX idx_reportes_fecha ON reportes (fecha_reporte);
    ```

* Plan de ejecución luego de ejecutar el indice:

    ```sql
    "Limit  (cost=52.31..54.42 rows=10 width=568) (actual time=0.403..0.436 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=52.31..105.52 rows=253 width=568) (actual time=0.402..0.434 rows=10 loops=1)"
    "        ->  Merge Join  (cost=52.16..96.33 rows=253 width=20) (actual time=0.368..0.388 rows=10 loops=1)"
    "              Merge Cond: (rep.fecha_reporte = ((registro.fecha_registro)::date))"
    "              ->  Index Scan using idx_reportes_fecha_reporte on reportes rep  (cost=0.15..32.55 rows=278 width=12) (actual time=0.071..0.082 rows=29 loops=1)"
    "              ->  GroupAggregate  (cost=52.01..57.39 rows=253 width=12) (actual time=0.220..0.289 rows=129 loops=1)"
    "                    Group Key: ((registro.fecha_registro)::date)"
    "                    ->  Sort  (cost=52.01..52.75 rows=296 width=4) (actual time=0.214..0.223 rows=161 loops=1)"
    "                          Sort Key: ((registro.fecha_registro)::date)"
    "                          Sort Method: quicksort  Memory: 25kB"
    "                          ->  Seq Scan on registro  (cost=0.00..39.86 rows=296 width=4) (actual time=0.013..0.162 rows=299 loops=1)"
    "                                Filter: ((fecha_inicial >= '2024-05-12 00:00:00'::timestamp without time zone) AND (fecha_inicial <= '2024-12-10 00:00:00'::timestamp without time zone))"
    "                                Rows Removed by Filter: 709"
    "        ->  Memoize  (cost=0.15..0.35 rows=1 width=520) (actual time=0.003..0.003 rows=1 loops=10)"
    "              Cache Key: rep.id_estado_reporte"
    "              Cache Mode: logical"
    "              Hits: 9  Misses: 1  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reporte_pkey on estado_reporte est  (cost=0.14..0.34 rows=1 width=520) (actual time=0.021..0.022 rows=1 loops=1)"
    "                    Index Cond: (id_estado_reporte = rep.id_estado_reporte)"
    "Planning Time: 1.822 ms"
    "Execution Time: 0.544 ms"
    ```

* Comparación de tiempos de ejecución:

    - Sin índice, el tiempo de ejecución fue de 2.065 ms.
    - Con el índice, el tiempo de ejecución fue de 0.544 ms.
    - Esto muestra una mejora del 73.6% en el tiempo de ejecución.
* Comparación de costos:

    - Sin índice, el costo fue de 73.08.
    - Con el índice, el costo fue de 54.42.
    - Esto muestra una reducción del 25.9% en el costo.
