# 9.1. Índices

## Módulos

### 1. Planificación del mantenimiento:
   
1) Índice para la búsqueda de planes de mantenimiento según la máquina a reparar:
    
* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.id_maquina = 8
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=62.13..62.14 rows=3 width=268) (actual time=0.173..0.174 rows=3 loops=1)"
    "  ->  Sort  (cost=62.13..62.14 rows=3 width=268) (actual time=0.171..0.172 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.59..62.11 rows=3 width=268) (actual time=0.056..0.164 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=0.44..61.41 rows=3 width=94) (actual time=0.043..0.147 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..45.39 rows=3 width=20) (actual time=0.033..0.133 rows=3 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=3 width=16) (actual time=0.022..0.117 rows=3 loops=1)"
    "                                Filter: (id_maquina = 8)"
    "                                Rows Removed by Filter: 997"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.003..0.003 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.674 ms"
    "Execution Time: 0.659 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Maquina_mantto
    ON Mantenimiento(id_maquina);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=52.46..52.46 rows=3 width=268) (actual time=0.129..0.131 rows=3 loops=1)"
    "  ->  Sort  (cost=52.46..52.46 rows=3 width=268) (actual time=0.127..0.129 rows=3 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=4.88..52.43 rows=3 width=268) (actual time=0.097..0.119 rows=3 loops=1)"
    "              ->  Nested Loop  (cost=4.73..51.73 rows=3 width=94) (actual time=0.082..0.098 rows=3 loops=1)"
    "                    ->  Nested Loop  (cost=4.57..35.72 rows=3 width=20) (actual time=0.070..0.080 rows=3 loops=1)"
    "                          ->  Bitmap Heap Scan on mantenimiento m  (cost=4.30..10.82 rows=3 width=16) (actual time=0.058..0.061 rows=3 loops=1)"
    "                                Recheck Cond: (id_maquina = 8)"
    "                                Heap Blocks: exact=2"
    "                                ->  Bitmap Index Scan on idx_maquina_mantto  (cost=0.00..4.30 rows=3 width=0) (actual time=0.052..0.052 rows=3 loops=1)"
    "                                      Index Cond: (id_maquina = 8)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.004..0.004 rows=1 loops=3)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Memoize  (cost=0.16..6.84 rows=1 width=82) (actual time=0.005..0.005 rows=1 loops=3)"
    "                          Cache Key: m.id_tipo_mant"
    "                          Cache Mode: logical"
    "                          Hits: 1  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                          ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..6.83 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                                Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.003..0.003 rows=1 loops=3)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 2.329 ms"
    "Execution Time: 0.232 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 62.14.
  - Luego de implementar, el costo nuevo es 52.46.
  - Esto muestra una reducción del 15.58% en costo.

1) Índice para la búsqueda de planes de mantenimiento según la fecha de inicio programada:

* Query utilizado:
    
    ```sql
    EXPLAIN ANALYZE
    SELECT LPAD(p.id_plan::TEXT, 4, '0') AS id_plan,
    CONCAT('MQ-',LPAD(m.id_maquina::TEXT, 4, '0')) AS id_maquina,
    tm.nombre_tipo_mant,
    c.nivel,
    m.fecha_inicio_programado 
    FROM Plan_de_Mantenimiento p 
    INNER JOIN Mantenimiento m 
    ON m.id_plan = p.id_plan 
    INNER JOIN Tipo_mantenimiento tm 
    ON tm.id_tipo_mant = m.id_tipo_mant 
    INNER JOIN Criticidad c 
    ON c.id_criticidad = p.id_criticidad 
	WHERE m.fecha_inicio_programado = DATE('2023-07-17')
    ORDER BY p.id_plan 
    LIMIT 10 
    OFFSET 1-1;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=37.24..37.25 rows=1 width=268) (actual time=0.293..0.294 rows=2 loops=1)"
    "  ->  Sort  (cost=37.24..37.25 rows=1 width=268) (actual time=0.273..0.274 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.58..37.23 rows=1 width=268) (actual time=0.181..0.250 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.43..37.00 rows=1 width=94) (actual time=0.154..0.219 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.28..28.81 rows=1 width=20) (actual time=0.136..0.198 rows=2 loops=1)"
    "                          ->  Seq Scan on mantenimiento m  (cost=0.00..20.50 rows=1 width=16) (actual time=0.110..0.166 rows=2 loops=1)"
    "                                Filter: (fecha_inicio_programado = '2023-07-17'::date)"
    "                                Rows Removed by Filter: 998"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.012..0.012 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.008..0.008 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 0.441 ms"
    "Execution Time: 0.367 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX IDX_Fecha_mantto
    ON Mantenimiento(fecha_inicio_programado)
    ```

    * Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=25.03..25.04 rows=1 width=268) (actual time=0.112..0.113 rows=2 loops=1)"
    "  ->  Sort  (cost=25.03..25.04 rows=1 width=268) (actual time=0.111..0.112 rows=2 loops=1)"
    "        Sort Key: p.id_plan"
    "        Sort Method: quicksort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.85..25.02 rows=1 width=268) (actual time=0.085..0.094 rows=2 loops=1)"
    "              ->  Nested Loop  (cost=0.70..24.79 rows=1 width=94) (actual time=0.069..0.075 rows=2 loops=1)"
    "                    ->  Nested Loop  (cost=0.55..16.60 rows=1 width=20) (actual time=0.060..0.065 rows=2 loops=1)"
    "                          ->  Index Scan using idx_fecha_mantto on mantenimiento m  (cost=0.28..8.29 rows=1 width=16) (actual time=0.048..0.049 rows=2 loops=1)"
    "                                Index Cond: (fecha_inicio_programado = '2023-07-17'::date)"
    "                          ->  Index Scan using plan_de_mantenimiento_pkey on plan_de_mantenimiento p  (cost=0.28..8.29 rows=1 width=8) (actual time=0.006..0.006 rows=1 loops=2)"
    "                                Index Cond: (id_plan = m.id_plan)"
    "                    ->  Index Scan using tipo_mantenimiento_pkey on tipo_mantenimiento tm  (cost=0.15..8.17 rows=1 width=82) (actual time=0.004..0.004 rows=1 loops=2)"
    "                          Index Cond: (id_tipo_mant = m.id_tipo_mant)"
    "              ->  Index Scan using criticidad_pkey on criticidad c  (cost=0.15..0.22 rows=1 width=122) (actual time=0.006..0.006 rows=1 loops=2)"
    "                    Index Cond: (id_criticidad = p.id_criticidad)"
    "Planning Time: 1.762 ms"
    "Execution Time: 0.155 ms"
    ```

* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 37.25.
  - Luego de implementar el índice, el costo nuevo es 25.04.
  - Esto muestra una reducción del 32.78% en costo.

---

### 2. Control del mantenimiento

### 3. Gestión de equipos de soporte

### 4. Gestión del IPERC

### 5. Gestión de insumos
---
1) Índice para la búsqueda de reservas con su estado actual ordenadas por fecha y hora.
    
* Query utilizado:
    
    ```sql
    explain analyse
    SELECT r.Id_reserva, e.Nombre_estado
    FROM Reserva r
    JOIN Estado_reserva e ON e.Id_estado_reserva = r.Id_estado_reserva
    WHERE r.Id_estado_reserva <> 0 AND r.Id_estado_reserva <> 3
    ORDER BY Fecha, Hora
    LIMIT 10 OFFSET 0;
    ```

* Plan de ejecución antes de implementar el índice:

    ```sql
    "Limit  (cost=10.01..10.03 rows=10 width=532) (actual time=0.194..0.198 rows=10 loops=1)"
    "  ->  Sort  (cost=10.01..10.16 rows=62 width=532) (actual time=0.192..0.194 rows=10 loops=1)"
    "        Sort Key: r.fecha, r.hora"
    "        Sort Method: top-N heapsort  Memory: 25kB"
    "        ->  Nested Loop  (cost=0.15..8.67 rows=62 width=532) (actual time=0.061..0.157 rows=57 loops=1)"
    "              ->  Seq Scan on reserva r  (cost=0.00..2.50 rows=62 width=20) (actual time=0.029..0.054 rows=57 loops=1)"
    "                    Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "                    Rows Removed by Filter: 43"
    "              ->  Memoize  (cost=0.15..0.95 rows=1 width=520) (actual time=0.001..0.001 rows=1 loops=57)"
    "                    Cache Key: r.id_estado_reserva"
    "                    Cache Mode: logical"
    "                    Hits: 55  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "                    ->  Index Scan using estado_reserva_pkey on estado_reserva e  (cost=0.14..0.94 rows=1 width=520) (actual time=0.012..0.012 rows=1 loops=2)"
    "                          Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 3.166 ms"
    "Execution Time: 0.259 ms"
    ```

* Implementación del índice:

    ```sql
    CREATE INDEX idx_reserva_fecha_hora ON Reserva(Fecha, Hora);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=0.30..3.53 rows=10 width=532) (actual time=0.167..0.199 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=0.30..20.31 rows=62 width=532) (actual time=0.165..0.195 rows=10 loops=1)"
    "        ->  Index Scan using idx_reserva_fecha_hora on reserva r  (cost=0.14..14.14 rows=62 width=20) (actual time=0.114..0.123 rows=10 loops=1)"
    "              Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "              Rows Removed by Filter: 3"
    "        ->  Memoize  (cost=0.15..0.95 rows=1 width=520) (actual time=0.006..0.006 rows=1 loops=10)"
    "              Cache Key: r.id_estado_reserva"
    "              Cache Mode: logical"
    "              Hits: 8  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using estado_reserva_pkey on estado_reserva e  (cost=0.14..0.94 rows=1 width=520) (actual time=0.021..0.021 rows=1 loops=2)"
    "                    Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 2.717 ms"
    "Execution Time: 0.263 ms"
    ```

* Implementación de segundo índice en la misma consulta:

    ```sql
    CREATE INDEX idx_estado_reserva ON Estado_reserva(Id_estado_reserva);
    ```

* Plan de ejecución luego de implementar el índice:

    ```sql
    "Limit  (cost=0.28..2.99 rows=10 width=532) (actual time=0.102..0.124 rows=10 loops=1)"
    "  ->  Nested Loop  (cost=0.28..17.10 rows=62 width=532) (actual time=0.100..0.120 rows=10 loops=1)"
    "        ->  Index Scan using idx_reserva_fecha_hora on reserva r  (cost=0.14..14.14 rows=62 width=20) (actual time=0.015..0.021 rows=10 loops=1)"
    "              Filter: ((id_estado_reserva <> 0) AND (id_estado_reserva <> 3))"
    "              Rows Removed by Filter: 3"
    "        ->  Memoize  (cost=0.14..0.35 rows=1 width=520) (actual time=0.009..0.009 rows=1 loops=10)"
    "              Cache Key: r.id_estado_reserva"
    "              Cache Mode: logical"
    "              Hits: 8  Misses: 2  Evictions: 0  Overflows: 0  Memory Usage: 1kB"
    "              ->  Index Scan using idx_estado_reserva on estado_reserva e  (cost=0.13..0.34 rows=1 width=520) (actual time=0.038..0.038 rows=1 loops=2)"
    "                    Index Cond: (id_estado_reserva = r.id_estado_reserva)"
    "Planning Time: 2.962 ms"
    "Execution Time: 0.187 ms"
    ```
* Comparación de costos:
  - Se observa que antes de implementar el índice, el costo máximo era de 10.01.
  - Luego de implementar el primer índice, el costo fue de 0.30.
  - Luego de implementar el segundo índice, el costo fue de 0.28.
  - Esto muestra una reducción del 97.2% en costo.

---
### 6. Seguridad

### 7. Gestión de reportes e historial de mantenimiento
